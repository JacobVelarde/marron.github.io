<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>RA Silueta de Coraz√≥n üç™ V1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background: #000;
    }
    video {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
      display: block;
      z-index: 0;
    }
    #canvasOutput {
      display: none;
    }
    a-scene {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 1;
    }
    #msg {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: rgba(0,0,0,0.6);
      color: #fff;
      text-align: center;
      font-size: 1.2em;
      padding: 12px;
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvasOutput"></canvas>

  <a-scene embedded vr-mode-ui="enabled: false">
    <a-assets>
      <a-asset-item id="heart3d" src="./src/monk_character.glb"></a-asset-item>
    </a-assets>

    <a-entity id="heartModel"
              gltf-model="#heart3d"
              scale="0 0 0"
              position="0 0 -3"
              animation__scale="property: scale; to: 0.3 0.3 0.3; dur: 600; easing: easeOutElastic;">
    </a-entity>

    <a-camera position="0 0 0"></a-camera>
  </a-scene>

  <div id="msg">üì∏ Aleja o acerca la c√°mara hasta que el coraz√≥n se vea completo.</div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvasOutput');
    const msg = document.getElementById('msg');
    const heartModel = document.getElementById('heartModel');

    // Iniciar c√°mara
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        video.srcObject = stream;
      })
      .catch(err => {
        msg.textContent = "‚ö†Ô∏è No se pudo acceder a la c√°mara: " + err.message;
      });

    let processing = false;

    // Esperar a que cargue OpenCV
    window.onload = function() {
      if (cv.getBuildInformation) {
        console.log("‚úÖ OpenCV listo");
        startDetection();
      } else {
        cv['onRuntimeInitialized'] = () => {
          console.log("‚úÖ OpenCV cargado");
          startDetection();
        };
      }
    };

    function startDetection() {
      const cap = new cv.VideoCapture(video);
      const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
      const gray = new cv.Mat();
      const edges = new cv.Mat();
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();

      function processVideo() {
        if (processing) return;
        processing = true;

        cap.read(src);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
        cv.Canny(gray, edges, 80, 150);

        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let detected = false;

        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area < 5000 || area > 50000) continue; // rango de tama√±o

          const rect = cv.boundingRect(cnt);
          const ratio = rect.width / rect.height;
          if (ratio > 0.8 && ratio < 1.2) {
            detected = true;
            break;
          }
        }

        if (detected) {
          msg.textContent = "üíñ ¬°Coraz√≥n detectado!";
          heartModel.setAttribute('scale', '0.3 0.3 0.3');
        } else {
          msg.textContent = "üì∏ Aleja o acerca la c√°mara hasta que el coraz√≥n se vea completo.";
          heartModel.setAttribute('scale', '0 0 0');
        }

        processing = false;
        requestAnimationFrame(processVideo);
      }

      requestAnimationFrame(processVideo);
    }
  </script>
</body>
</html>